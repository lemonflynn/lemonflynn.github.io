<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-08-28T11:10:56+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Slow and Fast</title><subtitle>Slow and fast are couple of relative concepts, i hope to record the fast changing tech(and world) in this slow way.</subtitle><entry><title type="html">Confusing about wire and reg in Verilog</title><link href="http://localhost:4000/fpga/2021/08/28/verilog-wire-reg-confusing.html" rel="alternate" type="text/html" title="Confusing about wire and reg in Verilog" /><published>2021-08-28T10:20:16+08:00</published><updated>2021-08-28T10:20:16+08:00</updated><id>http://localhost:4000/fpga/2021/08/28/verilog-wire-reg-confusing</id><content type="html" xml:base="http://localhost:4000/fpga/2021/08/28/verilog-wire-reg-confusing.html">&lt;h4 id=&quot;1-declare-pc_alu-as-a-register-and-use-always-to-assign-i_test-to-pc_alu-xilinx-systhesis-tool-will-treat-pc_alu-as-a-wire&quot;&gt;1. declare pc_alu as a register, and use always(*) to assign i_test to pc_alu. Xilinx systhesis tool will treat pc_alu as a wire.&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_val&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;always&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;o_val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;always&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/verilog/reg0.png&quot; alt=&quot;reg0&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-then-if-use-non-block-assignment-to-set-pc_alu-pc_alu-will-be-a-register-and-schematic-would-be-very-strange&quot;&gt;2. Then if use non-block assignment to set pc_alu, pc_alu will be a register, and schematic would be very strange.&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;always&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;always&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;negedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/verilog/reg1.png&quot; alt=&quot;reg1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-declare-pc_alu-as-a-wire-then-use-continuous-assignment-the-result-is-what-we-want-same-as-1&quot;&gt;3. Declare pc_alu as a wire, then use Continuous Assignment, the result is what we want, same as 1.&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;wire&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;always&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;o_val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc_alu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/verilog/wire.png&quot; alt=&quot;wire&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="FPGA" /><summary type="html">1. declare pc_alu as a register, and use always(*) to assign i_test to pc_alu. Xilinx systhesis tool will treat pc_alu as a wire. ```c module test( input i_clk, input i_reset, input i_test, output reg[3:0] o_val );</summary></entry><entry><title type="html">kvm io model</title><link href="http://localhost:4000/virtualization/2021/08/01/kvm-io.html" rel="alternate" type="text/html" title="kvm io model" /><published>2021-08-01T09:20:16+08:00</published><updated>2021-08-01T09:20:16+08:00</updated><id>http://localhost:4000/virtualization/2021/08/01/kvm-io</id><content type="html" xml:base="http://localhost:4000/virtualization/2021/08/01/kvm-io.html">&lt;p&gt;&lt;a href=&quot;/assets/kvm_io_model/kvm_io.pdf&quot;&gt;qemu-io&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="virtualization" /><summary type="html">qemu-io</summary></entry><entry><title type="html">linux workqueue implementation</title><link href="http://localhost:4000/kernel/2021/08/01/linux-workqueue.html" rel="alternate" type="text/html" title="linux workqueue implementation" /><published>2021-08-01T08:25:16+08:00</published><updated>2021-08-01T08:25:16+08:00</updated><id>http://localhost:4000/kernel/2021/08/01/linux-workqueue</id><content type="html" xml:base="http://localhost:4000/kernel/2021/08/01/linux-workqueue.html">&lt;p&gt;linux中的workqueue可以用来执行延迟执行一些操作，这些操作可以不是原子操作，一般可以用来实现中断的下半部。我们来分析一下它的实现机制。&lt;/p&gt;

&lt;p&gt;首先，使用如下函数创建workqueue:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define create_workqueue(name) __create_workqueue((name), 0, 0, 0)
#define create_singlethread_workqueue(name) __create_workqueue((name), 1, 0, 0)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;create_workqueue会在每个cpu上创建一个worker thread，create_singlethread_workqueue只会在cpu0上创建一个worker thread。其数据结构如下所示：
 &lt;img src=&quot;https://img-blog.csdnimg.cn/a82a47041fe348189052f0ac8dcf3a00.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc4MDI2MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; /&gt;
kernel使用list来管理所有的workqueue，list head为workqueues，每个workqueue_struct中包含了多个（和cpu核数相同）cpu_workqueue_struct，内核为每个cpu_workqueue创建了一个worker_thread，其中使用worklist来管理插入该queue中的work，以及一个wait_queue_head用来唤醒worker_thread的执行， 在worklist为空的时候，worker_thread会使用prepare_to_wait是自身进入sleep状态，并将自身加入到等待队列more_work中。&lt;/p&gt;

&lt;p&gt;使用如下接口来定义work：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;静态定义&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DECLARE_WORK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;动态定义&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;INIT_WORK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;有了workqueue和work后，就可以使用&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue_work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workqueue_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该函数将work插入到wq中对应cpu（调用该函数的cpu）的cpu_workqueue中的worklist，并使用wake_up(more_work)来唤醒workerthread去处理worklist。&lt;/p&gt;

&lt;p&gt;内核还准备了一个全局的workqueue，这样就只需要调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;schedule_work(struct work_struct *work)&lt;/code&gt;就可以将work放入keventfd_wq中。&lt;/p&gt;</content><author><name></name></author><category term="kernel" /><summary type="html">linux中的workqueue可以用来执行延迟执行一些操作，这些操作可以不是原子操作，一般可以用来实现中断的下半部。我们来分析一下它的实现机制。</summary></entry><entry><title type="html">Introduction about kvm and qemu</title><link href="http://localhost:4000/virtualization/2021/08/01/qemu-kvm-vm.html" rel="alternate" type="text/html" title="Introduction about kvm and qemu" /><published>2021-08-01T08:20:16+08:00</published><updated>2021-08-01T08:20:16+08:00</updated><id>http://localhost:4000/virtualization/2021/08/01/qemu-kvm-vm</id><content type="html" xml:base="http://localhost:4000/virtualization/2021/08/01/qemu-kvm-vm.html">&lt;p&gt;&lt;a href=&quot;/assets/qemu_kvm_vm/qemu-kvm.pdf&quot;&gt;qemu-kvm&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="virtualization" /><summary type="html">qemu-kvm</summary></entry><entry><title type="html">Qemu Thread Model</title><link href="http://localhost:4000/2021/08/01/qemu-thread-model.html" rel="alternate" type="text/html" title="Qemu Thread Model" /><published>2021-08-01T00:00:00+08:00</published><updated>2021-08-01T00:00:00+08:00</updated><id>http://localhost:4000/2021/08/01/qemu-thread-model</id><content type="html" xml:base="http://localhost:4000/2021/08/01/qemu-thread-model.html">&lt;h1 id=&quot;non-iothread&quot;&gt;non-iothread&lt;/h1&gt;
&lt;p&gt;早期的qemu并不支持多线程，它只有一个线程，在这个线程中完成vcpu、设备模拟和事件处理等逻辑；当该线程正在执行vcpu虚拟机的代码时，如果此时虚拟机发生了一个异常或该线程收到了一个信号，则cpu从执行虚拟机的代码切换到qemu代码，然后根据select的返回结果去处理对应的文件描述符，等完成设备的模拟逻辑后，就接着执行虚拟机的代码。&lt;/p&gt;
&lt;h1 id=&quot;iothread&quot;&gt;iothread&lt;/h1&gt;
&lt;p&gt;non-iothread的模型并不能利用多核处理器的性能，假如传入-smp 2，即要虚拟出2个vcpu，此时qemu也只有一个线程，在该线程中轮流交替的选择一个vcpu来运行，其也只是用到了一个物理cpu。&lt;/p&gt;

&lt;p&gt;新的线程模型是为每一个vcpu分配一个线程，外加一个main loop线程（用来监听文件描述符、eventfd、定时器和中断下半部），可能还会有设备的worker thread（用来卸载main loop的负载，例如vnc）。因为QEMU的代码不是thread-safe的，也就意味着QEMU的代码不能同时被多个线程运行，所以需要一个全局mutex来保证。当vcpu从guest code中退出到qemu中时，需要运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qemu_mutex_lock_iothread&lt;/code&gt;来获取这个全局锁，之后才能执行QEMU的代码；在进入guest code前使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qemu_mutex_unlock_iothread&lt;/code&gt;来释放该锁。&lt;/p&gt;

&lt;h1 id=&quot;引用&quot;&gt;引用&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.vmsplice.net/2011/03/qemu-internals-overall-architecture-and.html&quot;&gt;QEMU Internals: Overall architecture and threading model&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.vmsplice.net/2020/08/qemu-internals-event-loops.html&quot;&gt;QEMU Internals: Event loops&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">non-iothread 早期的qemu并不支持多线程，它只有一个线程，在这个线程中完成vcpu、设备模拟和事件处理等逻辑；当该线程正在执行vcpu虚拟机的代码时，如果此时虚拟机发生了一个异常或该线程收到了一个信号，则cpu从执行虚拟机的代码切换到qemu代码，然后根据select的返回结果去处理对应的文件描述符，等完成设备的模拟逻辑后，就接着执行虚拟机的代码。 iothread non-iothread的模型并不能利用多核处理器的性能，假如传入-smp 2，即要虚拟出2个vcpu，此时qemu也只有一个线程，在该线程中轮流交替的选择一个vcpu来运行，其也只是用到了一个物理cpu。</summary></entry></feed>